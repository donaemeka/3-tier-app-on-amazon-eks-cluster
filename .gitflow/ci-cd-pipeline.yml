# .github/workflows/ci-cd-pipeline.yml

name: CI/CD Pipeline - Voting App
run-name: ${{ github.actor }} is deploying to EKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allows manual triggering from GitHub UI

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      # Use git tag if available, otherwise use commit SHA
      IMAGE_TAG: ${{ github.ref_type == 'tag' && github.ref_name || github.sha }}
    
    steps:
    # Step 1: Checkout code from repository
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for proper versioning

    # Step 2: Set up Docker Buildx for better builds
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # Step 3: Login to Docker Hub
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    # Step 4: Build and push VOTE microservice
    - name: Build and push Vote image
      uses: docker/build-push-action@v5
      with:
        context: ./vote  # Path to vote app directory
        file: ./vote/Dockerfile
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/voting-app-vote:${{ env.IMAGE_TAG }}
          ${{ secrets.DOCKER_USERNAME }}/voting-app-vote:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    # Step 5: Build and push RESULT microservice  
    - name: Build and push Result image
      uses: docker/build-push-action@v5
      with:
        context: ./result  # Path to result app directory
        file: ./result/Dockerfile
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/voting-app-result:${{ env.IMAGE_TAG }}
          ${{ secrets.DOCKER_USERNAME }}/voting-app-result:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    # Step 6: Build and push WORKER microservice
    - name: Build and push Worker image
      uses: docker/build-push-action@v5
      with:
        context: ./worker  # Path to worker app directory
        file: ./worker/Dockerfile
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/voting-app-worker:${{ env.IMAGE_TAG }}
          ${{ secrets.DOCKER_USERNAME }}/voting-app-worker:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    # Step 7: Configure AWS credentials for EKS access
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    # Step 8: Install kubectl
    - name: Install kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        kubectl version --client

    # Step 9: Update kubeconfig to access your EKS cluster
    - name: Update kubeconfig for EKS
      run: |
        aws eks update-kubeconfig \
          --region ${{ secrets.AWS_REGION }} \
          --name ${{ secrets.AWS_CLUSTER }}

    # Step 10: Update Kubernetes manifests with new image tags
    - name: Update image tags in Kubernetes manifests
      run: |
        # Replace 'latest' tags with the new image tags in all YAML files
        sed -i "s|donaemeka/voting-app-vote:latest|${{ secrets.DOCKER_USERNAME }}/voting-app-vote:${{ env.IMAGE_TAG }}|g" k8s/*.yaml
        sed -i "s|donaemeka/voting-app-result:latest|${{ secrets.DOCKER_USERNAME }}/voting-app-result:${{ env.IMAGE_TAG }}|g" k8s/*.yaml
        sed -i "s|donaemeka/voting-app-worker:latest|${{ secrets.DOCKER_USERNAME }}/voting-app-worker:${{ env.IMAGE_TAG }}|g" k8s/*.yaml
        
        echo "‚úÖ Updated image tags in Kubernetes manifests"
        echo "New vote image: ${{ secrets.DOCKER_USERNAME }}/voting-app-vote:${{ env.IMAGE_TAG }}"
        echo "New result image: ${{ secrets.DOCKER_USERNAME }}/voting-app-result:${{ env.IMAGE_TAG }}"
        echo "New worker image: ${{ secrets.DOCKER_USERNAME }}/voting-app-worker:${{ env.IMAGE_TAG }}"

    # Step 11: Deploy to EKS cluster
    - name: Deploy to EKS
      run: |
        echo "üöÄ Deploying to EKS cluster: ${{ secrets.AWS_CLUSTER }}"
        kubectl apply -f k8s/
        
        echo "üìã Deployment status:"
        kubectl get pods -o wide
        kubectl get services
        kubectl get ingress

    # Step 12: Verify deployment
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        kubectl rollout status deployment/vote --timeout=300s
        kubectl rollout status deployment/result --timeout=300s
        kubectl rollout status deployment/worker --timeout=300s
        
        echo "‚úÖ All deployments successful!"
        echo "üåê Application URLs:"
        kubectl get ingress -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' && echo